<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name=viewport
          content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>HTML5 draw and drag</title>

    <script src="http://code.jquery.com/jquery-1.11.3.min.js">// js/jquery-1.7.min.js"</script>
    <script src="modernizr.custom.34982.js"></script>

    <script src="SVGDraw.js"></script>
    <!--<script src="js/trigonometry.js"></script>-->

    <link rel="stylesheet" href="assets/bootstrap.css"/>
    <link rel="stylesheet" href="assets/styles.css"/>

    <script>
        var svgDraw = null;
        var xC = 0;
        var yC = 0;
        var cursorMode = "MOVE";
        var cursorColor = '#ff0000'
        var strokeWidth = '10';
        var zoom = 0.2;         /////////////////////////////
        var baseZoom = 0.2;         /////////////////////////////
        var maxZoom = 4;
        var svgImage = new Image();
        var thisSvg = [];            // collect points as [x,y]
        var svgOffset;              // set on document ready

        var thisSvgText;            // pointer to svg control currently being populated
        var textHeight = 75;
        var textFont = 'Verdana';

        var waitElement = false;

        var thisDraw;

        //        var thisRectangle;

        //        var thisLine;

        //        var thisPolyline;

        //        var thisPolygon;

        //        var thisCircle;

        //        var thisEllipse;

        var thisGroup;

        var savedCursorMode = cursorMode;

        var thisElement;

        var thisBubble;

        var svgInProgress = false;

        var lastMouseX;
        var lastMouseY;

        var logMouse = false;
        var logStatus = false;
        var logIndex = 0;
        //canvas_image.src = undefined;
        //        svgImage.src = "../../../../spec/support/images/frost_stage.jpg";
        svgImage.src = 'frost_stage.jpg';  //'tiger.svg';     // 'stitch-3.tif';

        $(document).ready(function (e) {
            svgDraw = new SVGDraw("svgLayer");
            svgOffset = {
                top: document.getElementById(svgDraw.canvasID).parentNode.style.top.split('px')[0],
                left: document.getElementById(svgDraw.canvasID).parentNode.style.left.split('px')[0]
            };
            indicateMode(cursorMode);
            document.getElementById("text4svg").onkeyup = updateSvgText;
//    canvas = document.getElementById("sketch");
//    context = canvas.getContext("2d");
//    setMove();
//    renderImage();
        });

        $(svgImage).load(function () {
            xC = 0;
            yC = 0;
            baseZoom = document.getElementById('svgLayer').width.baseVal.value / svgImage.width;     // in general more complicated than this
            zoom = baseZoom;
            lastMouseX = baseZoom * svgImage.width / 2;
            lastMouseY = baseZoom * svgImage.height / 2;
            // insert the svg base image into the transformable group <g id='xlt'>
            var xlt = document.getElementById('xlt');
            var xltImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
            xltImage.setAttributeNS(null, 'id', "xltImage");
            xltImage.setAttributeNS(null, 'x', "0");
            xltImage.setAttributeNS(null, 'y', "0");
            xltImage.setAttributeNS(null, 'width', svgImage.width.toString());
            xltImage.setAttributeNS(null, 'height', svgImage.height.toString());
            xltImage.setAttributeNS(null, 'preserveAspectRatio', "none");
            xltImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', svgImage.src);
            xlt.appendChild(xltImage);
            zoom_trans(0, 0, zoom);             //////////// IMPORTANT !!!!!!!!!!!

//            canvas = document.getElementById("sketch");     // set up the dynamic draw layer
//            context = canvas.getContext("2d");
            setMove();
        });

        function clearCanvas() {
            svgDraw.clear();
            xC = 0;
            yC = 0;
            renderImage();
        }
        //        function setDraw() {
        //            cursorMode = "PATH";
        //            indicateMode();
        //        }

        function setMove() {
            cursorMode = "MOVE";
            indicateMode(cursorMode);
        }

        function indicateMode(mode) {
            var coverRect = mode;
            if (mode == 'rect') {
                coverRect = 'rectangle';        // replace anomalous rect with rectangle
            }
            document.getElementById("mode").textContent = coverRect.toUpperCase();
            $("#zoom").html("Zoom:" + zoom.toFixed(3));
        }

        function clearGroup() {
            var xlt = document.getElementById("xlt");
            if (xlt.childElementCount > 1) {
                xlt.lastChild.remove();
            }
        }

        function setCursorMode(mode) {      // detect current mode not completed prior to mode switch
            if (true/*(cursorMode != mode) && (svgInProgress == cursorMode)*/) {        // iff switched mode while in progress
                svgInProgress = false;                                      // //////// does this ^ matter?
                if (thisElement != null) {
                    showStatus('setCursorMode0', thisGroup);
                    checkLeftoverElement();     // look for dangling element, most likely off of svg image element ( - Y coord)
                    clearEditElement(thisGroup);        //  TODO: make sure all cases complete
                }
            }
            if (mode.toUpperCase() == 'MOVE') {
                cursorMode = mode;
            }
            else {
                cursorMode = mode.toLowerCase();
            }
//  eliminated savedCursorMode = 'MOVE';
            waitElement = true;
            indicateMode(mode);
            showStatus('setCursorMode1', thisGroup);
        }

        function setTextMode() {
            setCursorMode('text');
            document.getElementById("text4svg").removeAttribute('disabled');
        }

        function checkLeftoverElement() {       // this function is only called when svgInProgress is false (?)
            switch (cursorMode) {
                case 'polyline':
                case 'polygon':
                    // this seems to ONLY delete the last point, so disabled pending better treatment
//                    var thesePoints = thisElement.attributes['points'].value.trim();
//                    var splitPoints = thesePoints.split(' ');
//                    thesePoints = '';
//                    for (k = 0; k < splitPoints.length - 2; k++) {
//                        thesePoints += splitPoints[k] + ' ';
//                    }
//                    thisElement.attributes['points'].value = thesePoints;
                    break;
//                    var thesePoints = thisElement.attributes['points'].value;
//                    var splitPoints = thesePoints.split(' ');
//                    thesePoints = '';
//                    for (k = 0; k < splitPoints.length - 2; k++) {
//                        thesePoints += splitPoints[k] + ' ';
//                    }
//                    thisElement.attributes['points'].value = thesePoints;
//                    break;
                case 'circle':
                    if (thisElement == null) return;
                    if (((thisElement.attributes['cy'].value - thisElement.attributes['r'].value) < 0)     // off canvas
                            || (thisElement.attributes['r'].value < 2))                                          // single click
                    {
                        clearGroup();       // this was a leftover
                    }
                    break;
                case 'ellipse':
                    if (thisElement == null) return;
                    if ((thisElement.attributes['cy'].value - thisElement.attributes['ry'].value) < 0) {
                        clearGroup();       // this was a leftover
                    }
                    break;
                case 'rect':
                    if (thisElement == null) return;
                    if ((thisElement.attributes['height'].value) < 0) {
                        clearGroup();       // this was a leftover
                    }
                    break;
                case 'line':
                    if ((thisElement.attributes['y2'].value) < 0) {
                        clearGroup();       // this was a leftover
                    }
                    break;
            }
        }

        function inverseColor(color) {          // color is required to be string as #RRGGBB hexadecimal
            var red = makeHex8(color.slice(1, 3));
            var grn = makeHex8(color.slice(3, 5));
            var blu = makeHex8(color.slice(5, 7));
            return '#' + red + grn + blu;
        }

        function makeHex8(colorSegment) {       // colorSegment is 8 bit hex encoded string
            var izit = ((parseInt('0X' + colorSegment)) ^ 0xFF).toString(16)
            if (izit.length == 2) {
                return izit;
            }
            return '0' + izit;
        }

        function zoomIn() {
            var zoomDelta = 0.05;
            if (zoom < maxZoom) {           // zoom of 1 iz pixel-per-pixel on canvas/svg
                var newZoom = zoom * ( 1.0 + zoomDelta);
                if (newZoom > maxZoom) {
                    newZoom = maxZoom;
                }
                xC = lastMouseX - (lastMouseX - xC) * newZoom / zoom;
                yC = lastMouseY - (lastMouseY - yC) * newZoom / zoom;
                zoom_trans(0, 0, newZoom);
                zoom = newZoom;
                $("#zoom").html("Zoom:" + zoom.toFixed(3));
            }
        }

        function zoomOut() {
            var zoomDelta = 0.05;
            if (zoom > baseZoom / 3) {
                var newZoom = zoom / (1.0 + zoomDelta);
                xC = lastMouseX - (lastMouseX - xC) * newZoom / zoom;
                yC = lastMouseY - (lastMouseY - yC) * newZoom / zoom;
                zoom_trans(0, 0, newZoom);
                zoom = newZoom;
                $("#zoom").html("Zoom:" + zoom.toFixed(3));
            }
        }

        function zoom_trans(x, y, factor) {
            var xlt = document.getElementById('xlt');         // DOM svg element g xlt
            var transform = 'translate(' + ((xC)).toString() + ', ' + ((yC)).toString() + ')scale(' + factor.toString() + ')';
            xlt.attributes['transform'].value = transform;
            $("#zoom").html("Zoom:" + zoom.toFixed(3));
            $("#coords").html('xC: ' + xC.toFixed(1) + ' xM: ' + x + ' lastX: ' + lastMouseX.toFixed(3)
                    + ' yC: ' + yC.toFixed(1) + ' y: ' + y + ' lastY: ' + lastMouseY.toFixed(3));
        }

        function updateSvgText(event) {
            var text4svg = document.getElementById("text4svg");
            if (thisSvgText == null) {
                return false
            }
            if (event.keyCode == 27) {      // terminate this text block on ESC
                if (thisSvgText.parentElement.lastChild.innerHTML.length == 0) {
                    thisSvgText.parentElement.lastChild.remove();
                }
                closeSvgText();
                checkLeftoverElement();
                return false;
            }
            thisSvgText.innerHTML = text4svg.value;
            thisSvgText.attributes['stroke'].value = cursorColor;       // allow in-line whole line color/font/size over-ride
            thisSvgText.attributes['style'].value = 'font-family: ' + textFont + '; fill: ' + cursorColor + ';';    //  including fill
            thisSvgText.attributes['font-size'].value = textHeight;
            var nextX = thisSvgText.attributes['x'].value;
            var nextY = parseInt(thisSvgText.attributes['y'].value) + parseInt(textHeight);
            var nextLine = thisSvgText.cloneNode();
            if (event.keyCode == 13) {      // line feed on ENTER/CR
                var thisInverse = inverseColor(cursorColor);
//                thisSvgText.attributes['onmouseover'] = 'this.attributes["stroke"].value = ' + thisInverse + ';';
                nextLine.attributes['x'].value = nextX;
                nextLine.attributes['y'].value = nextY;
                thisSvgText.parentElement.appendChild(nextLine);
                thisSvgText = nextLine;
                text4svg.value = '';
            }
        }

        function closeSvgText() {
            var text4svg = document.getElementById("text4svg");
            text4svg.value = '';
            text4svg.setAttribute('disabled', 'true');
            text4svg.blur();
//            thisSvgText.attributes['onmouseover'].value = "this.attributes['stroke'].value = '" + inverseColor(cursorColor)
//                    + "'; this.attributes['fill'].value = '" + inverseColor(cursorColor) + "';";
//            thisSvgText.attributes['onmouseover'].value = "this.attributes['stroke'].value = " + inverseColor(cursorColor) + ";";
//            thisSvgText.attributes['onmouseout'].value = "this.attributes['stroke'].value = " + cursorColor
//                    + "; this.attributes['stroke-width'].value = " + strokeWidth + ";";

            thisSvgText = null;         // remove the target
            thisSvg = [];               // clear the container
            setCursorMode('MOVE');
        }

        function setCursorColor(color) {
            cursorColor = color;
            document.getElementById('cursorColor').attributes['style'].value = 'background-color: ' + cursorColor;
        }

        function setUserColor(color) {          // only sets up the color for later selection
            document.getElementById('setUserColor').attributes['style'].value = 'background-color: ' + color;
        }

        function getUserColor() {
            return document.getElementById('userColor').value;

        }

        //        function renderImage() {
        //            if (xC >= canvas_image.width - canvas.width) {
        //                xC = canvas_image.width - canvas.width;
        //            }
        //    xC, yC is -left, -top boundary of canvas, [also source point of canvas_image - no longer used]
        //    want to window the canvas_image into the canvas isometrically
        //    and proportional to zoom level
        //
        ////            if ((xC - canvas_image.width) * zoom >= canvas.width) {   // clip on xC
        ////                xC = (canvas_image.width - canvas.width) * zoom;
        ////            }
        //            if (yC >= canvas_image.height - canvas.height) {
        //                yC = canvas_image.height - canvas.height;
        //            }
        //            if (xC < 0) {
        //                xC = 0;
        //            }
        //            if (yC < 0) {
        //                yC = 0;
        //            }
        ////            context.fillOpacity = "0.0";
        //            context.clearRect(0, 0, canvas.width, canvas.height);
        //        }

        // TODO:
        // bounds check on move (in svgDraw.js)
        // aspect ratio compensation source to target canvas
        // capture svg data - DONE
        // source image from http://
    </script>
    <style type='text/css'>
        #container {
            overflow: hidden;
            width: 800px;
            height: 600px;
        }
    </style>

</head>

<div class="topbar-wrapper" style="z-index: 5;">
    <div class="topbar" data-dropdown="dropdown">
        <div class="topbar-inner">
            <div class="container">
                <h3><a href="#">Image annotation using direct overlay on svg root element</a></h3>

                <ul class="nav">
                    <li class="active">Annotate image using heavily modified sketcher app using its mouse events
                        structure<br>
                        with scroll zoom. Implemented: Text, Circle, Ellipse, Polygon, Polyline, Rectangle, Line and
                        Draw.
                    </li>
                </ul>

                <ul class="nav secondary-nav">
                    <input type="button" class="btn error" value="Clear Last Element" onclick="clearGroup();"/>
                    <input type="button" class="btn error" value="Polygon" onclick="setCursorMode('polygon');"/>
                    <input type="button" class="btn error" value="Polyline" onclick="setCursorMode('polyline');"/>
                    <input type="button" class="btn error" value="Rectangle" onclick="setCursorMode('rect');"/>
                    <input type="button" class="btn error" value="Line" onclick="setCursorMode('line');"/>
                    <input type="button" class="btn error" value="Circle" onclick="setCursorMode('circle');"/>
                    <input type="button" class="btn error" value="Ellipse" onclick="setCursorMode('ellipse');"/>
                    <!--<input type="button" class="btn error" value="Path" onclick="setCursorMode('PATH');"/>-->
                    <input type="button" class="btn error" value="Draw" onclick="setCursorMode('draw');"/>
                    <span id="mode"></span>
                    <input type="button" value="Move" onclick="setCursorMode('MOVE');"/>
                    <input type="button" value="Text" onclick="setTextMode();"/>
                    <input type="button" value="Zoom IN" onclick="zoomIn();"/>
                    <span id="zoom">Zoom: ---</span>
                    <input type="button" value="Zoom OUT" onclick="zoomOut();"/>
                    Text size:
                    <input id=textSize type="number" min="5" max="300" step="5" value="75" style="width: 4em"
                           onchange="textHeight=this.value;"/>
                    <input type="text" id="text4svg" disabled/>
                    <br>
                    <input type="button" id="setRed" style="background-color: #FF0000"
                           onclick="setCursorColor('#FF0000');"/>
                    <input type="button" id="setBlue" style="background-color: #0000FF"
                           onclick="setCursorColor('#0000FF');"/>
                    <input type="button" id="setGreen" style="background-color: #00FF00"
                           onclick="setCursorColor('#00FF00');"/>
                    <input type="button" id="setBlack" style="background-color: #000000"
                           onclick="setCursorColor('#000000');"/>
                    <input id="userColor" type="text" value="#AAAAAA" style="width: 6em"
                           onchange="/*setCursorColor(this.value);*/ setUserColor(this.value);"/>
                    <input type="button" id="setUserColor" style="background-color: #888888"
                           onclick="setCursorColor(getUserColor());"/> Selected Color:
                    <input type="button" id="cursorColor" style="background-color: #FF0000"/>

                    </li>
                </ul>
            </div>
        </div>
        <!-- /topbar-inner -->
    </div>
    <!-- /topbar -->
</div>
<div id="container" style="overflow: hidden; left: 50px; top: 175px; position: absolute;">
    <svg id="svgLayer" width="800" height="600" xmlns="http://www.w3.org/2000/svg" version="1.1"
         style="position: inherit;">
        <g id="xlt" transform="translate(0,0)scale(0.20)">
        </g>
    </svg>
    <!--<canvas id="sketch" width="800" height="600" style="opacity: 0.8">-->
    <!--&lt;!&ndash;<canvas id="sketch" width="800" height="600" style="left: 0px; top: 0px; position: absolute; opacity: 0.8">&ndash;&gt;-->
    <!--</canvas>-->
</div>
<div style="top: 775px; position: absolute;">
    <span id="coords"></span><br/><span id="mouseStatus"></span>
</div>
</body>
</html>
