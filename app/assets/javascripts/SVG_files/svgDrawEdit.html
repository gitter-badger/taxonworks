<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name=viewport
          content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>HTML5 draw and drag</title>

    <script src="http://code.jquery.com/jquery-1.11.3.min.js">// js/jquery-1.7.min.js"</script>
    <script src="modernizr.custom.34982.js"></script>

    <script src="SVGDraw.js"></script>
    <!--<script src="js/trigonometry.js"></script>-->

    <link rel="stylesheet" href="assets/bootstrap.css"/>
    <link rel="stylesheet" href="assets/styles.css"/>

    <script>
        /*
         Discussion/tradeoff issues with SVGDraw as of 01DEC2015:

         Scale and normalize image to container (only partially correct now)
         (aspect ratio compensation source to target svg)
         Explicit edit mode versus auto mouseenter
         Specific style parameters per svg element type
         "Semantic" zoom applied to bubbles on creation (vis a vis real-time)
         Tableau of function mode buttons/indicators
         HOT-KEYS for: abort last individual point (e.g., escape)
         abort last element (e.g., delete)
         finish current element (e.g., enter)
         enter/inhibit mouse"over" editing
         SPACE held down to drag-pan
         Export svg markup (currently elements are partially corrupted)
         Packaging:
         verbatim
         style vs element segregation

         "Stacking" issues - tokenize elements for selection outside the image.
         Move [element] to the top function
         After the fact grouping
         Eliminate jQuery?
         Color picker
         Measurement specifier and tool (caliper)
         +/- 90 degree text orientation
         ARROW super-element

         Librarization:  data- elements to define configuration
         auto-generate html
         only require a div with data- elements
         JSON configuration?

         // bounds check on move (in svgDraw.js) ?
         // capture svg data - DONE
         // source image from http://

         */
        var svgDraw = null;
        var xC = 0;
        var yC = 0;
        var cursorMode = "MOVE";
        var cursorColor = '#ff0000'
        var zoom = 0.2;         ///////////////////////////  should be set on initialization from baseZoom @ full image
        var baseStrokeWidth = 1;
        var baseBubbleRadius = 6;
        var strokeWidth = (baseStrokeWidth / zoom).toString();    // dynamically recomputed with zoom (not this one)
        var bubbleRadius = (baseBubbleRadius / zoom).toString(); // and transcoded from/to string (may not be required)
        var baseZoom = 0.2;         ///////////////////////////// should be calculated from svg and image attributes
        var maxZoom = 4;        // this is 4 pixels per source image pixel
        var svgImage = new Image();
        var thisSvg = [];            // collect points as [x,y]
        var svgOffset;              // set on document ready ////////// test against fully packaged code

        var thisSvgText;            // pointer to svg text element currently being populated
        var textHeight = 75;
        var textFont = 'Verdana';

        var waitElement = false;

        var thisDraw;

        //        var thisRectangle;

        //        var thisLine;

        //        var thisPolyline;

        //        var thisPolygon;

        //        var thisCircle;

        //        var thisEllipse;

        var thisGroup;              // should be the parent of the current element

        var savedCursorMode = cursorMode;

        var thisElement;

        var thisBubble;             // the bubble mousedown-ed in the currently edited element

        var svgInProgress = false;

        var lastMouseX;
        var lastMouseY;

        var logMouse = false;       // debug
        var logStatus = false;      // flags
        var logIndex = 0;           // limit counter for above
        //        svgImage.src = "../../../../spec/support/images/frost_stage.jpg";
        svgImage.src = 'frost_stage.jpg';  //'tiger.svg';     // 'stitch-3.tif';

        $(document).ready(function (e) {
            svgDraw = new SVGDraw("svgLayer");
            svgOffset = {
                top: document.getElementById(svgDraw.canvasID).parentNode.style.top.split('px')[0],
                left: document.getElementById(svgDraw.canvasID).parentNode.style.left.split('px')[0]
            };
            indicateMode(cursorMode);
            document.getElementById("text4svg").onkeyup = updateSvgText;
        });

        $(svgImage).load(function () {
            xC = 0;
            yC = 0;
            baseZoom = document.getElementById('svgLayer').width.baseVal.value / svgImage.width;     // in general more complicated than this
            zoom = baseZoom;
            lastMouseX = baseZoom * svgImage.width / 2;
            lastMouseY = baseZoom * svgImage.height / 2;
            // insert the svg base image into the transformable group <g id='xlt'>
            var xlt = document.getElementById('xlt');
            var xltImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
            xltImage.setAttributeNS(null, 'id', "xltImage");
            xltImage.setAttributeNS(null, 'x', "0");
            xltImage.setAttributeNS(null, 'y', "0");
            xltImage.setAttributeNS(null, 'width', svgImage.width.toString());
            xltImage.setAttributeNS(null, 'height', svgImage.height.toString());
            xltImage.setAttributeNS(null, 'preserveAspectRatio', "none");
            xltImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', svgImage.src);
            xlt.appendChild(xltImage);
            zoom_trans(0, 0, zoom);             //////////// IMPORTANT !!!!!!!!!!!

            setMove();
        });

        function clearCanvas() {
            svgDraw.clear();
            xC = 0;
            yC = 0;
            renderImage();
        }
        //        function setDraw() {
        //            cursorMode = "PATH";
        //            indicateMode();
        //        }

        function setMove() {
            cursorMode = "MOVE";
            indicateMode(cursorMode);
        }

        function indicateMode(mode) {
            var coverRect = mode;
            if (mode == 'rect') {
                coverRect = 'rectangle';        // replace anomalous rect with rectangle
            }
            document.getElementById("mode").textContent = coverRect.toUpperCase();
            $("#zoom").html("Zoom:" + zoom.toFixed(3));
        }

        function clearGroup() {
            var xlt = document.getElementById("xlt");
            if (xlt.childElementCount > 1) {
                xlt.lastChild.remove();
            }
        }

        function setCursorMode(mode) {      // detect current mode not completed prior to mode switch
            if (true/*(cursorMode != mode) && (svgInProgress == cursorMode)*/) {        // iff switched mode while in progress
                svgInProgress = false;                                      // //////// does this ^ matter?
                if (thisElement != null) {
                    showStatus('setCursorMode0', thisGroup);
                    checkLeftoverElement();     // look for dangling element, most likely off of svg image element ( - Y coord)
                    clearEditElement(thisGroup);        //  TODO: make sure all cases complete
                }
            }
            if (mode.toUpperCase() == 'MOVE') {
                cursorMode = mode;
            }
            else {
                cursorMode = mode.toLowerCase();
            }
//  eliminated savedCursorMode = 'MOVE';
            waitElement = true;
            indicateMode(mode);
            showStatus('setCursorMode1', thisGroup);
        }

        function setTextMode() {
            setCursorMode('text');
            document.getElementById("text4svg").removeAttribute('disabled');
            document.getElementById("text4svg").focus();
        }

        function checkLeftoverElement() {       // this function is only called when svgInProgress is false (?)
            switch (cursorMode) {
                case 'polyline':
                case 'polygon':
                    // this seems to ONLY delete the last point, so disabled pending better treatment
//                    var thesePoints = thisElement.attributes['points'].value.trim();
//                    var splitPoints = thesePoints.split(' ');
//                    thesePoints = '';
//                    for (k = 0; k < splitPoints.length - 2; k++) {
//                        thesePoints += splitPoints[k] + ' ';
//                    }
//                    thisElement.attributes['points'].value = thesePoints;
                    break;
//                    var thesePoints = thisElement.attributes['points'].value;
//                    var splitPoints = thesePoints.split(' ');
//                    thesePoints = '';
//                    for (k = 0; k < splitPoints.length - 2; k++) {
//                        thesePoints += splitPoints[k] + ' ';
//                    }
//                    thisElement.attributes['points'].value = thesePoints;
//                    break;
                case 'circle':
                    if (thisElement == null) return;
                    if (((thisElement.attributes['cy'].value - thisElement.attributes['r'].value) < 0)     // off canvas
                            || (thisElement.attributes['r'].value < 2))                                          // single click
                    {
                        clearGroup();       // this was a leftover
                    }
                    break;
                case 'ellipse':
                    if (thisElement == null) return;
                    if ((thisElement.attributes['cy'].value - thisElement.attributes['ry'].value) < 0) {
                        clearGroup();       // this was a leftover
                    }
                    break;
                case 'rect':
                    if (thisElement == null) return;
                    if ((thisElement.attributes['height'].value) < 0) {
                        clearGroup();       // this was a leftover
                    }
                    break;
                case 'line':
                    if ((thisElement.attributes['y2'].value) < 0) {
                        clearGroup();       // this was a leftover
                    }
                    break;
            }
        }

        function inverseColor(color) {          // color is required to be string as #RRGGBB hexadecimal
            var red = makeHex8(color.slice(1, 3));
            var grn = makeHex8(color.slice(3, 5));
            var blu = makeHex8(color.slice(5, 7));
            return '#' + red + grn + blu;
        }

        function makeHex8(colorSegment) {       // colorSegment is 8 bit hex encoded string
            var izit = ((parseInt('0X' + colorSegment)) ^ 0xFF).toString(16)
            if (izit.length == 2) {
                return izit;
            }
            return '0' + izit;
        }

        function zoomIn() {
            var zoomDelta = 0.05;
            if (zoom < maxZoom) {           // zoom of 1 iz pixel-per-pixel on canvas/svg
                var newZoom = zoom * ( 1.0 + zoomDelta);
                if (newZoom > maxZoom) {
                    newZoom = maxZoom;
                }
                xC = lastMouseX - (lastMouseX - xC) * newZoom / zoom;
                yC = lastMouseY - (lastMouseY - yC) * newZoom / zoom;
                zoom_trans(0, 0, newZoom);
                zoom = newZoom;
                bubbleRadius = (baseBubbleRadius / zoom).toString();
                $("#zoom").html("Zoom:" + zoom.toFixed(3));
            }
        }

        function zoomOut() {
            var zoomDelta = 0.05;
            if (zoom > baseZoom / 3) {
                var newZoom = zoom / (1.0 + zoomDelta);
                xC = lastMouseX - (lastMouseX - xC) * newZoom / zoom;
                yC = lastMouseY - (lastMouseY - yC) * newZoom / zoom;
                zoom_trans(0, 0, newZoom);
                zoom = newZoom;
                bubbleRadius = (baseBubbleRadius / zoom).toString();
                $("#zoom").html("Zoom:" + zoom.toFixed(3));
            }
        }

        function zoom_trans(x, y, factor) {
            var xlt = document.getElementById('xlt');         // DOM svg element g xlt
            var transform = 'translate(' + ((xC)).toString() + ', ' + ((yC)).toString() + ')scale(' + factor.toString() + ')';
            xlt.attributes['transform'].value = transform;
            $("#zoom").html("Zoom:" + zoom.toFixed(3));
            $("#coords").html('xC: ' + xC.toFixed(1) + ' xM: ' + x + ' lastX: ' + lastMouseX.toFixed(3)
                    + ' yC: ' + yC.toFixed(1) + ' y: ' + y + ' lastY: ' + lastMouseY.toFixed(3));
        }

        function updateSvgText(event) {
            var text4svg = document.getElementById("text4svg");
            if (thisSvgText == null) {
                return false
            }
            if (event.keyCode == 27) {      // terminate this text block on ESC
                if (thisSvgText.parentElement.lastChild.innerHTML.length == 0) {
                    thisSvgText.parentElement.lastChild.remove();
                }
                closeSvgText();
                checkLeftoverElement();
                return false;
            }
            thisSvgText.innerHTML = text4svg.value;
            thisSvgText.attributes['stroke'].value = cursorColor;       // allow in-line whole line color/font/size over-ride
            thisSvgText.attributes['style'].value = 'font-family: ' + textFont + '; fill: ' + cursorColor + ';';    //  including fill
            thisSvgText.attributes['font-size'].value = textHeight;
            var nextX = thisSvgText.attributes['x'].value;
            var nextY = parseInt(thisSvgText.attributes['y'].value) + parseInt(textHeight);
            var nextLine = thisSvgText.cloneNode();
            if (event.keyCode == 13) {      // line feed on ENTER/CR
                var thisInverse = inverseColor(cursorColor);
//                thisSvgText.attributes['onmouseover'] = 'this.attributes["stroke"].value = ' + thisInverse + ';';
                nextLine.attributes['x'].value = nextX;
                nextLine.attributes['y'].value = nextY;
                thisSvgText.parentElement.appendChild(nextLine);
                thisSvgText = nextLine;
                text4svg.value = '';
            }
        }

        function closeSvgText() {
            var text4svg = document.getElementById("text4svg");
            text4svg.value = '';
            text4svg.setAttribute('disabled', 'true');
            text4svg.blur();
//            thisSvgText.attributes['onmouseover'].value = "this.attributes['stroke'].value = '" + inverseColor(cursorColor)
//                    + "'; this.attributes['fill'].value = '" + inverseColor(cursorColor) + "';";
//            thisSvgText.attributes['onmouseover'].value = "this.attributes['stroke'].value = " + inverseColor(cursorColor) + ";";
//            thisSvgText.attributes['onmouseout'].value = "this.attributes['stroke'].value = " + cursorColor
//                    + "; this.attributes['stroke-width'].value = " + strokeWidth + ";";

            thisSvgText = null;         // remove the target
            thisSvg = [];               // clear the container
            setCursorMode('MOVE');
        }

        function setCursorColor(color) {
            cursorColor = color;
            document.getElementById('cursorColor').attributes['style'].value = 'background-color: ' + cursorColor;
        }

        function setUserColor(color) {          // only sets up the color for later selection
            document.getElementById('setUserColor').attributes['style'].value = 'background-color: ' + color;
        }

        function getUserColor() {
            return document.getElementById('userColor').value;

        }
    </script>
    <style type='text/css'>
        #container {
            overflow: hidden;
            width: 800px;
            height: 600px;
        }
    </style>

</head>

<div class="topbar-wrapper" style="z-index: 5;">
    <div class="topbar" data-dropdown="dropdown">
        <div class="topbar-inner">
            <div class="container">
                <h3><a href="#">Image annotation using direct overlay on svg root element</a></h3>

                <ul class="nav">
                    <li class="active">Annotate image using heavily modified sketcher app using its mouse events
                        structure<br>
                        with scroll zoom. Implemented: Text, Circle, Ellipse, Polygon, Polyline, Rectangle, Line and
                        Draw.
                    </li>
                </ul>

                <ul class="nav secondary-nav"><!-- this should be generated and inserted from configuration code -->
                    <input type="button" class="btn error" value="Clear Last Element" onclick="clearGroup();"/>
                    <input type="button" class="btn error" value="Polygon" onclick="setCursorMode('polygon');"/>
                    <input type="button" class="btn error" value="Polyline" onclick="setCursorMode('polyline');"/>
                    <input type="button" class="btn error" value="Rectangle" onclick="setCursorMode('rect');"/>
                    <input type="button" class="btn error" value="Line" onclick="setCursorMode('line');"/>
                    <input type="button" class="btn error" value="Circle" onclick="setCursorMode('circle');"/>
                    <input type="button" class="btn error" value="Ellipse" onclick="setCursorMode('ellipse');"/>
                    <input type="button" class="btn error" value="Draw" onclick="setCursorMode('draw');"/>
                    <input type="button" class="btn error" value="Cubic" onclick="setCursorMode('curve');"/>
                    <input type="button" class="btn error" value="Quadratic" onclick="setCursorMode('curve');"/>
                    <span id="mode"></span>
                    <input type="button" value="Move" onclick="setCursorMode('MOVE');"/>
                    <input type="button" value="Text" onclick="setTextMode();"/>
                    <input type="button" value="Zoom IN" onclick="zoomIn();"/>
                    <span id="zoom">Zoom: ---</span>
                    <input type="button" value="Zoom OUT" onclick="zoomOut();"/>
                    Text size:
                    <input id=textSize type="number" min="5" max="300" step="5" value="75" style="width: 4em"
                           onchange="textHeight=this.value;"/>
                    <input type="text" id="text4svg" disabled/>
                    <br>
                    <input type="button" id="setRed" style="background-color: #FF0000"
                           onclick="setCursorColor('#FF0000');"/>
                    <input type="button" id="setBlue" style="background-color: #0000FF"
                           onclick="setCursorColor('#0000FF');"/>
                    <input type="button" id="setGreen" style="background-color: #00FF00"
                           onclick="setCursorColor('#00FF00');"/>
                    <input type="button" id="setBlack" style="background-color: #000000"
                           onclick="setCursorColor('#000000');"/>
                    <input id="userColor" type="text" value="#666666" style="width: 5em"
                           onchange="/*setCursorColor(this.value);*/ setUserColor(this.value);"/>
                    <input type="button" id="setUserColor" style="background-color: #666666"
                           onclick="setCursorColor(getUserColor());"/> Selected Color:
                    <input type="button" id="cursorColor" style="background-color: #FF0000"/>

                    </li>
                </ul>
            </div>
        </div>
        <!-- /topbar-inner -->
    </div>
    <!-- /topbar -->
</div>
<div id="container" style="overflow: hidden; left: 50px; top: 175px; position: absolute;">
    <svg id="svgLayer" width="800" height="600" xmlns="http://www.w3.org/2000/svg" version="1.1"
         style="position: inherit;">
        <g id="xlt" transform="translate(0,0)scale(0.20)"><!-- this should be generated and inserted by init JS code -->
        </g>
    </svg>
</div>
<div style="top: 775px; position: absolute;"><!-- debug output area -->
    <span id="coords"></span><br/><span id="mouseStatus"></span>
</div>
</body>
</html>
